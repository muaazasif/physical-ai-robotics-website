"use strict";(globalThis.webpackChunkphysical_ai_robotics_website=globalThis.webpackChunkphysical_ai_robotics_website||[]).push([[940],{4020:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"chapter_5_control_architecture","title":"Chapter 5: Control Architectures and System Integration for Humanoid Robotics","description":"5.1 Introduction to Control Architectures","source":"@site/docs/chapter_5_control_architecture.md","sourceDirName":".","slug":"/chapter_5_control_architecture","permalink":"/physical-ai-robotics-website/docs/chapter_5_control_architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/muaazasif/physical-ai-robotics-website/docs/chapter_5_control_architecture.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 4: Machine Learning and AI Algorithms for Humanoid Robotics","permalink":"/physical-ai-robotics-website/docs/chapter_4_ml_algorithms"},"next":{"title":"Chapter 6: Sensors and Perception Systems for Humanoid Robotics","permalink":"/physical-ai-robotics-website/docs/chapter_6_sensors_perception"}}');var a=t(4848),o=t(8453);const r={},i="Chapter 5: Control Architectures and System Integration for Humanoid Robotics",l={},c=[{value:"5.1 Introduction to Control Architectures",id:"51-introduction-to-control-architectures",level:2},{value:"5.2 Hierarchical Control Architecture",id:"52-hierarchical-control-architecture",level:2},{value:"5.2.1 Three-Tier Control Architecture",id:"521-three-tier-control-architecture",level:3},{value:"5.2.2 Detailed Component Breakdown",id:"522-detailed-component-breakdown",level:3},{value:"5.3 Control System Flowcharts",id:"53-control-system-flowcharts",level:2},{value:"5.3.1 Main Control Loop Flowchart",id:"531-main-control-loop-flowchart",level:3},{value:"5.3.2 Behavior Selection Flowchart",id:"532-behavior-selection-flowchart",level:3},{value:"5.3.3 Balance Control Flowchart",id:"533-balance-control-flowchart",level:3},{value:"5.4 System Integration Architecture",id:"54-system-integration-architecture",level:2},{value:"5.4.1 Component Integration Flow",id:"541-component-integration-flow",level:3},{value:"5.4.2 Data Flow Architecture",id:"542-data-flow-architecture",level:3},{value:"5.5 Real-Time Control Architectures",id:"55-real-time-control-architectures",level:2},{value:"5.5.1 Multi-Rate Control System",id:"551-multi-rate-control-system",level:3},{value:"5.5.2 Hierarchical State Machine",id:"552-hierarchical-state-machine",level:3},{value:"5.6 Software Architecture Patterns",id:"56-software-architecture-patterns",level:2},{value:"5.6.1 Component-Based Architecture",id:"561-component-based-architecture",level:3},{value:"5.6.2 Publish-Subscribe Pattern Implementation",id:"562-publish-subscribe-pattern-implementation",level:3},{value:"5.6.3 Hierarchical Task Decomposition",id:"563-hierarchical-task-decomposition",level:3},{value:"5.7 Control System Integration Patterns",id:"57-control-system-integration-patterns",level:2},{value:"5.7.1 Service-Oriented Architecture",id:"571-service-oriented-architecture",level:3},{value:"5.7.2 Action Server Integration",id:"572-action-server-integration",level:3},{value:"5.8 Integration Testing and Validation",id:"58-integration-testing-and-validation",level:2},{value:"5.8.1 System Integration Test Framework",id:"581-system-integration-test-framework",level:3},{value:"5.9 Real-World Integration Considerations",id:"59-real-world-integration-considerations",level:2},{value:"5.9.1 Hardware-Software Integration Challenges",id:"591-hardware-software-integration-challenges",level:3},{value:"5.9.2 System Reliability and Fault Tolerance",id:"592-system-reliability-and-fault-tolerance",level:3},{value:"5.11 Summary",id:"511-summary",level:2},{value:"5.12 Discussion Questions",id:"512-discussion-questions",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"chapter-5-control-architectures-and-system-integration-for-humanoid-robotics",children:"Chapter 5: Control Architectures and System Integration for Humanoid Robotics"})}),"\n",(0,a.jsx)(n.h2,{id:"51-introduction-to-control-architectures",children:"5.1 Introduction to Control Architectures"}),"\n",(0,a.jsx)(n.p,{children:"Humanoid robotics control architectures are complex hierarchical systems that coordinate multiple levels of control, from low-level motor commands to high-level task planning. These architectures must balance real-time performance, safety, adaptability, and modularity while managing the intricate dynamics of human-like robots."}),"\n",(0,a.jsx)(n.p,{children:"The control hierarchy typically consists of multiple layers:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"High-level cognitive control"}),": Task planning, decision making, and goal selection"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Mid-level behavioral control"}),": Mode switching, behavior selection, and coordination"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Low-level motor control"}),": Joint control, balance maintenance, and trajectory execution"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"52-hierarchical-control-architecture",children:"5.2 Hierarchical Control Architecture"}),"\n",(0,a.jsx)(n.h3,{id:"521-three-tier-control-architecture",children:"5.2.1 Three-Tier Control Architecture"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502    HIGH-LEVEL CONTROLLER        \u2502\n                    \u2502  (Task Planning & Reasoning)    \u2502\n                    \u2502  \u2022 Goal selection               \u2502\n                    \u2502  \u2022 Task decomposition           \u2502\n                    \u2502  \u2022 Motion planning              \u2502\n                    \u2502  \u2022 Decision making              \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                  \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502     MID-LEVEL CONTROLLER  \u2502\n                    \u2502  (Behavior & Coordination)\u2502\n                    \u2502  \u2022 Behavior selection     \u2502\n                    \u2502  \u2022 Mode switching         \u2502\n                    \u2502  \u2022 Inter-task coordination\u2502\n                    \u2502  \u2022 Safety monitoring      \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                  \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502              LOW-LEVEL CONTROLLER              \u2502\n         \u2502           (Motor & Balance Control)            \u2502\n         \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n         \u2502  \u2502 JOINT CONTROLLER\u2502  \u2502 BALANCE CONTROLLER   \u2502 \u2502\n         \u2502  \u2502 \u2022 Torque control\u2502  \u2502 \u2022 COG control        \u2502 \u2502\n         \u2502  \u2502 \u2022 Position hold \u2502  \u2502 \u2022 ZMP regulation     \u2502 \u2502\n         \u2502  \u2502 \u2022 Compliance    \u2502  \u2502 \u2022 Fall prevention    \u2502 \u2502\n         \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n         \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n         \u2502  \u2502 WALK CONTROLLER \u2502  \u2502 MANIPULATION         \u2502 \u2502\n         \u2502  \u2502 \u2022 Step planning \u2502  \u2502 \u2022 Inverse kinematics \u2502 \u2502\n         \u2502  \u2502 \u2022 Foot placement\u2502  \u2502 \u2022 Grasp planning     \u2502 \u2502\n         \u2502  \u2502 \u2022 Gait control  \u2502  \u2502 \u2022 Trajectory gen.    \u2502 \u2502\n         \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(n.h3,{id:"522-detailed-component-breakdown",children:"5.2.2 Detailed Component Breakdown"}),"\n",(0,a.jsx)(n.p,{children:"Let's examine each level in detail with their interactions and dependencies:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"High-Level Controller Components:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Task Planner: Generates high-level plans based on goals"}),"\n",(0,a.jsx)(n.li,{children:"State Estimator: Maintains world model and robot state"}),"\n",(0,a.jsx)(n.li,{children:"Decision Maker: Selects appropriate behaviors"}),"\n",(0,a.jsx)(n.li,{children:"Trajectory Generator: Creates reference trajectories"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Mid-Level Controller Components:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Behavior Manager: Coordinates active behaviors"}),"\n",(0,a.jsx)(n.li,{children:"Mode Selector: Manages state transitions"}),"\n",(0,a.jsx)(n.li,{children:"Safety Supervisor: Monitors and enforces safety"}),"\n",(0,a.jsx)(n.li,{children:"Resource Allocator: Distributes computational resources"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Low-Level Controller Components:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Joint Controllers: Individual joint servo control"}),"\n",(0,a.jsx)(n.li,{children:"Balance Controller: Whole-body balance maintenance"}),"\n",(0,a.jsx)(n.li,{children:"Walk Controller: Locomotion pattern generation"}),"\n",(0,a.jsx)(n.li,{children:"Manipulation Controller: Arm and hand control"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"53-control-system-flowcharts",children:"5.3 Control System Flowcharts"}),"\n",(0,a.jsx)(n.h3,{id:"531-main-control-loop-flowchart",children:"5.3.1 Main Control Loop Flowchart"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:"flowchart TD\n    A[Start Control Cycle] --\x3e B[Acquire Sensor Data]\n    B --\x3e C[Estimate Robot State]\n    C --\x3e D{Check Safety Conditions}\n    D --\x3e|Safe| E[Run High-Level Planner]\n    D --\x3e|Unsafe| F[Trigger Safety Mode]\n    F --\x3e G[Stop All Motion]\n    G --\x3e A\n    E --\x3e H[Run Behavior Selection]\n    H --\x3e I[Execute Low-Level Control]\n    I --\x3e J[Send Actuator Commands]\n    J --\x3e K[Wait for Next Cycle]\n    K --\x3e A\n"})}),"\n",(0,a.jsx)(n.h3,{id:"532-behavior-selection-flowchart",children:"5.3.2 Behavior Selection Flowchart"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:"flowchart TD\n    A[Behavior Selection Triggered] --\x3e B[Get Current State]\n    B --\x3e C[Get Available Behaviors]\n    C --\x3e D[Calculate Behavior Utilities]\n    D --\x3e E[Select Highest Utility Behavior]\n    E --\x3e F{Validate Behavior Transition}\n    F --\x3e|Valid| G[Execute Behavior]\n    F --\x3e|Invalid| H[Select Next Best Behavior]\n    H --\x3e F\n    G --\x3e I[Update Behavior State]\n    I --\x3e J[Return to Control Loop]\n    J --\x3e K{Behavior Complete?}\n    K --\x3e|No| I\n    K --\x3e|Yes| L[Behavior Complete]\n    L --\x3e M[Return to Control Loop]\n"})}),"\n",(0,a.jsx)(n.h3,{id:"533-balance-control-flowchart",children:"5.3.3 Balance Control Flowchart"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:"flowchart TD\n    A[Balance Control Cycle] --\x3e B[Get Sensor Data]\n    B --\x3e C[Calculate Zero Moment Point]\n    C --\x3e D{ZMP within Support Polygon?}\n    D --\x3e|Yes| E[Calculate Desired COG Adjustments]\n    D --\x3e|No| F[Emergency Balance Response]\n    E --\x3e G[Generate Joint Torques]\n    F --\x3e H[Compensate for Instability]\n    H --\x3e I[Check for Recovery]\n    I --\x3e J{Recovery Successful?}\n    J --\x3e|Yes| G\n    J --\x3e|No| K[Fall Prevention Protocol]\n    G --\x3e L{Balance Achieved?}\n    L --\x3e|No| M[Iterate Balance Correction]\n    L --\x3e|Yes| N[Normal Operation]\n    N --\x3e O[Return to Control Loop]\n    M --\x3e C\n    K --\x3e P[Execute Controlled Fall]\n    P --\x3e O\n"})}),"\n",(0,a.jsx)(n.h2,{id:"54-system-integration-architecture",children:"5.4 System Integration Architecture"}),"\n",(0,a.jsx)(n.h3,{id:"541-component-integration-flow",children:"5.4.1 Component Integration Flow"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:'graph TB\n    subgraph "Perception Layer"\n        A[Camera] --\x3e A1[Image Processing]\n        B[IMU] --\x3e B1[State Estimation] \n        C[Lidar] --\x3e C1[Environment Mapping]\n        D[Force/Torque] --\x3e D1[Contact Detection]\n    end\n    \n    subgraph "Cognition Layer"  \n        A1 --\x3e E[Task Planner]\n        B1 --\x3e E\n        C1 --\x3e E\n        D1 --\x3e E\n    end\n    \n    subgraph "Control Layer"\n        E --\x3e F[Behavior Manager]\n        F --\x3e G[Walk Controller]\n        F --\x3e H[Arm Controller]\n        F --\x3e I[Balance Controller]\n        F --\x3e J[Head Controller]\n    end\n    \n    subgraph "Actuation Layer"\n        G --\x3e K1[Leg Joint Drivers]\n        H --\x3e L1[Arm Joint Drivers] \n        I --\x3e M1[Torso Joint Drivers]\n        J --\x3e N1[Head Joint Drivers]\n    end\n    \n    subgraph "Physical Layer"\n        K1 --\x3e P1[Physical Legs]\n        L1 --\x3e P2[Physical Arms]\n        M1 --\x3e P3[Physical Torso]\n        N1 --\x3e P4[Physical Head]\n    end\n'})}),"\n",(0,a.jsx)(n.h3,{id:"542-data-flow-architecture",children:"5.4.2 Data Flow Architecture"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:'graph LR\n    subgraph "Sensor Fusion"\n        A[Raw Sensor Data] --\x3e B[Filter & Calibrate]\n        B --\x3e C[Data Association]\n        C --\x3e D[State Estimation]\n    end\n    \n    subgraph "Decision Making"\n        D --\x3e E[Behavior Reasoning]\n        E --\x3e F[Action Selection]\n        F --\x3e G[Path Planning]\n    end\n    \n    subgraph "Control Execution"\n        G --\x3e H[Trajectory Generation]\n        H --\x3e I[Inverse Kinematics]\n        I --\x3e J[Motor Commands]\n    end\n    \n    subgraph "Feedback Loop"\n        J --\x3e K[Motor Execution]\n        K --\x3e A\n    end\n'})}),"\n",(0,a.jsx)(n.h2,{id:"55-real-time-control-architectures",children:"5.5 Real-Time Control Architectures"}),"\n",(0,a.jsx)(n.h3,{id:"551-multi-rate-control-system",children:"5.5.1 Multi-Rate Control System"}),"\n",(0,a.jsx)(n.p,{children:"Humanoid robots require different control rates for different subsystems:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:"gantt\n    title Multi-Rate Control Timeline\n    section High-Level Control\n    Planning         :done, des1, 2023-01-01, 0.1s\n    Decision Making  :active, 2023-01-01, 0.05s\n    \n    section Mid-Level Control\n    Behavior Selection :2023-01-01, 0.01s\n    Mode Switching     :2023-01-01, 0.005s\n    \n    section Low-Level Control\n    Balance Control    :2023-01-01, 0.001s\n    Joint Servo      :2023-01-01, 0.0005s\n    Safety Monitoring:2023-01-01, 0.0001s\n"})}),"\n",(0,a.jsx)(n.h3,{id:"552-hierarchical-state-machine",children:"5.5.2 Hierarchical State Machine"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:"stateDiagram-v2\n    [*] --\x3e IDLE : System Start\n    IDLE --\x3e WALKING : Walk Request\n    IDLE --\x3e STANDING : Stand Request  \n    IDLE --\x3e SITTING : Sit Request\n    \n    WALKING --\x3e STANDING : Stop Request\n    WALKING --\x3e EMERGENCY : Balance Lost\n    STANDING --\x3e WALKING : Walk Request\n    STANDING --\x3e IDLE : Neutral Position\n    SITTING --\x3e STANDING : Stand Up\n    \n    EMERGENCY --\x3e RECOVERY : Recovery Possible\n    EMERGENCY --\x3e SAFETY : Recovery Impossible\n    RECOVERY --\x3e IDLE : Recovery Complete\n    SAFETY --\x3e [*] : System Shutdown\n"})}),"\n",(0,a.jsx)(n.h2,{id:"56-software-architecture-patterns",children:"5.6 Software Architecture Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"561-component-based-architecture",children:"5.6.1 Component-Based Architecture"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:'componentDiagram\n    component "PerceptionManager" as PM\n    component "MotionPlanner" as MP  \n    component "Balancer" as B\n    component "WalkController" as WC\n    component "JointController" as JC\n    component "SafetyMonitor" as SM\n    \n    PM --\x3e MP : sensor_data\n    MP --\x3e B : target_pose\n    MP --\x3e WC : walk_command\n    B --\x3e JC : joint_commands\n    WC --\x3e JC : step_parameters\n    SM --\x3e B : safety_limits\n    SM --\x3e WC : safety_limits\n    SM --\x3e JC : emergency_stop\n'})}),"\n",(0,a.jsx)(n.h3,{id:"562-publish-subscribe-pattern-implementation",children:"5.6.2 Publish-Subscribe Pattern Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nPublish-Subscribe pattern for humanoid control system\nDemonstrates decoupled communication between components\n"""\n\nimport time\nimport threading\nfrom typing import Dict, List, Callable\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass MessageType(Enum):\n    SENSOR_DATA = "sensor_data"\n    CONTROL_COMMAND = "control_command"\n    SYSTEM_STATE = "system_state"\n    BEHAVIOR_REQUEST = "behavior_request"\n    SAFETY_ALERT = "safety_alert"\n\n@dataclass\nclass Message:\n    msg_type: MessageType\n    data: dict\n    timestamp: float\n    sender: str\n\nclass EventBus:\n    """Central event bus for message passing"""\n    def __init__(self):\n        self.subscribers: Dict[MessageType, List[Callable]] = {}\n        self.lock = threading.Lock()\n        \n    def subscribe(self, msg_type: MessageType, callback: Callable):\n        """Subscribe to a message type"""\n        with self.lock:\n            if msg_type not in self.subscribers:\n                self.subscribers[msg_type] = []\n            self.subscribers[msg_type].append(callback)\n    \n    def publish(self, message: Message):\n        """Publish a message to all subscribers"""\n        with self.lock:\n            callbacks = self.subscribers.get(message.msg_type, [])\n        \n        for callback in callbacks:\n            try:\n                callback(message)\n            except Exception as e:\n                print(f"Error in subscriber callback: {e}")\n\nclass SensorManager:\n    """Component that manages sensor data"""\n    def __init__(self, event_bus: EventBus):\n        self.event_bus = event_bus\n        self.event_bus.subscribe(MessageType.BEHAVIOR_REQUEST, self.handle_behavior_request)\n        self.running = False\n    \n    def start(self):\n        """Start sensor data acquisition"""\n        self.running = True\n        self.sensor_thread = threading.Thread(target=self.sensor_loop)\n        self.sensor_thread.start()\n    \n    def sensor_loop(self):\n        """Main sensor acquisition loop"""\n        while self.running:\n            # Simulate sensor data\n            sensor_data = {\n                \'joint_positions\': [0.1, 0.2, 0.3, 0.4, 0.5, 0.6],\n                \'imu_data\': {\'roll\': 0.01, \'pitch\': 0.02, \'yaw\': 0.03},\n                \'force_sensors\': [10, 15, 20, 25],\n                \'camera_data\': {\'objects\': [], \'distances\': []}\n            }\n            \n            msg = Message(\n                msg_type=MessageType.SENSOR_DATA,\n                data=sensor_data,\n                timestamp=time.time(),\n                sender=\'SensorManager\'\n            )\n            self.event_bus.publish(msg)\n            \n            time.sleep(0.01)  # 100Hz sensor update\n    \n    def handle_behavior_request(self, message: Message):\n        """Handle behavior requests that might affect sensor focus"""\n        print(f"SensorManager received behavior request: {message.data}")\n\nclass MotionPlanner:\n    """Component that plans robot motion"""\n    def __init__(self, event_bus: EventBus):\n        self.event_bus = event_bus\n        self.event_bus.subscribe(MessageType.SENSOR_DATA, self.process_sensor_data)\n        self.event_bus.subscribe(MessageType.BEHAVIOR_REQUEST, self.handle_behavior_request)\n        \n        self.current_behavior = "idle"\n        self.goal_position = [0, 0, 0]\n        \n    def process_sensor_data(self, message: Message):\n        """Process incoming sensor data to update plans"""\n        if self.current_behavior == "walking":\n            # Simple walking logic\n            sensor_data = message.data\n            current_pos = sensor_data[\'joint_positions\'][:3]  # First 3 joints represent position\n            \n            # Simple gait control\n            if abs(current_pos[0] - self.goal_position[0]) > 0.1:\n                walk_command = {\n                    \'step_length\': 0.2,\n                    \'step_height\': 0.05,\n                    \'direction\': \'forward\'\n                }\n                \n                cmd_msg = Message(\n                    msg_type=MessageType.CONTROL_COMMAND,\n                    data=walk_command,\n                    timestamp=time.time(),\n                    sender=\'MotionPlanner\'\n                )\n                self.event_bus.publish(cmd_msg)\n    \n    def handle_behavior_request(self, message: Message):\n        """Handle behavior change requests"""\n        behavior = message.data.get(\'behavior\', \'idle\')\n        self.current_behavior = behavior\n        \n        if behavior == \'walk\':\n            self.goal_position = message.data.get(\'goal\', [1.0, 0, 0])\n        elif behavior == \'stand\':\n            self.goal_position = [0, 0, 0]\n\nclass BalanceController:\n    """Component that maintains robot balance"""\n    def __init__(self, event_bus: EventBus):\n        self.event_bus = event_bus\n        self.event_bus.subscribe(MessageType.SENSOR_DATA, self.process_sensor_data)\n        self.event_bus.subscribe(MessageType.CONTROL_COMMAND, self.handle_control_command)\n        \n        self.zmp_reference = [0, 0]\n        self.balance_gain = 10.0\n    \n    def process_sensor_data(self, message: Message):\n        """Process sensor data for balance control"""\n        sensor_data = message.data\n        imu_data = sensor_data.get(\'imu_data\', {})\n        \n        # Calculate balance correction\n        pitch_error = imu_data.get(\'pitch\', 0)\n        roll_error = imu_data.get(\'roll\', 0)\n        \n        # Simple balance correction\n        balance_correction = {\n            \'torso_pitch\': -pitch_error * self.balance_gain,\n            \'torso_roll\': -roll_error * self.balance_gain\n        }\n        \n        # Check if emergency balance is needed\n        if abs(pitch_error) > 0.2 or abs(roll_error) > 0.2:\n            safety_msg = Message(\n                msg_type=MessageType.SAFETY_ALERT,\n                data={\'level\': \'high\', \'reason\': \'Imminent fall\'},\n                timestamp=time.time(),\n                sender=\'BalanceController\'\n            )\n            self.event_bus.publish(safety_msg)\n        \n        cmd_msg = Message(\n            msg_type=MessageType.CONTROL_COMMAND,\n            data=balance_correction,\n            timestamp=time.time(),\n            sender=\'BalanceController\'\n        )\n        self.event_bus.publish(cmd_msg)\n    \n    def handle_control_command(self, message: Message):\n        """Handle control commands that affect balance"""\n        if \'balance_params\' in message.data:\n            for param, value in message.data[\'balance_params\'].items():\n                setattr(self, param, value)\n\nclass SafetyMonitor:\n    """Component that monitors system safety"""\n    def __init__(self, event_bus: EventBus):\n        self.event_bus = event_bus\n        self.event_bus.subscribe(MessageType.SENSOR_DATA, self.monitor_sensors)\n        self.event_bus.subscribe(MessageType.SAFETY_ALERT, self.handle_safety_alert)\n        \n        self.safety_limits = {\n            \'joint_position\': 1.5,\n            \'imu_angle\': 0.3,\n            \'current_draw\': 10.0\n        }\n        self.system_safe = True\n    \n    def monitor_sensors(self, message: Message):\n        """Monitor sensor data for safety violations"""\n        sensor_data = message.data\n        \n        # Check joint positions\n        joint_positions = sensor_data.get(\'joint_positions\', [])\n        for pos in joint_positions:\n            if abs(pos) > self.safety_limits[\'joint_position\']:\n                self.trigger_safety_alert(f"Joint position limit exceeded: {pos}")\n        \n        # Check IMU data\n        imu_data = sensor_data.get(\'imu_data\', {})\n        pitch = imu_data.get(\'pitch\', 0)\n        roll = imu_data.get(\'roll\', 0)\n        \n        if abs(pitch) > self.safety_limits[\'imu_angle\'] or abs(roll) > self.safety_limits[\'imu_angle\']:\n            self.trigger_safety_alert(f"IMU angle exceeded: pitch={pitch}, roll={roll}")\n    \n    def trigger_safety_alert(self, reason):\n        """Trigger a safety alert"""\n        safety_msg = Message(\n            msg_type=MessageType.SAFETY_ALERT,\n            data={\'level\': \'medium\', \'reason\': reason},\n            timestamp=time.time(),\n            sender=\'SafetyMonitor\'\n        )\n        self.event_bus.publish(safety_msg)\n    \n    def handle_safety_alert(self, message: Message):\n        """Handle incoming safety alerts"""\n        alert_data = message.data\n        print(f"SAFETY ALERT [{alert_data[\'level\']}]: {alert_data[\'reason\']}")\n        \n        if alert_data[\'level\'] == \'high\':\n            # Send emergency stop\n            stop_msg = Message(\n                msg_type=MessageType.CONTROL_COMMAND,\n                data={\'command\': \'emergency_stop\'},\n                timestamp=time.time(),\n                sender=\'SafetyMonitor\'\n            )\n            self.event_bus.publish(stop_msg)\n\ndef main():\n    """Main system demonstration"""\n    print("Initializing humanoid control system...")\n    \n    # Create event bus\n    event_bus = EventBus()\n    \n    # Create components\n    sensor_manager = SensorManager(event_bus)\n    motion_planner = MotionPlanner(event_bus)\n    balance_controller = BalanceController(event_bus)\n    safety_monitor = SafetyMonitor(event_bus)\n    \n    # Start sensor manager\n    sensor_manager.start()\n    \n    # Send a behavior request to start walking\n    walk_request = Message(\n        msg_type=MessageType.BEHAVIOR_REQUEST,\n        data={\'behavior\': \'walk\', \'goal\': [2.0, 0, 0]},\n        timestamp=time.time(),\n        sender=\'User\'\n    )\n    event_bus.publish(walk_request)\n    \n    # Run for a while\n    time.sleep(5)\n    \n    # Stop\n    sensor_manager.running = False\n    print("System stopped.")\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,a.jsx)(n.h3,{id:"563-hierarchical-task-decomposition",children:"5.6.3 Hierarchical Task Decomposition"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nHierarchical task decomposition system for humanoid robotics\nDemonstrates how complex tasks are broken down into simpler subtasks\n"""\n\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nimport time\n\nclass TaskStatus(Enum):\n    PENDING = "pending"\n    RUNNING = "running"\n    SUCCESS = "success"\n    FAILED = "failed"\n    CANCELLED = "cancelled"\n\n@dataclass\nclass Task:\n    """Base class for tasks in the hierarchy"""\n    id: str\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    priority: int = 0\n    subtasks: List[\'Task\'] = None\n    dependencies: List[str] = None\n    estimated_duration: float = 0.0\n    actual_duration: float = 0.0\n    \n    def __post_init__(self):\n        if self.subtasks is None:\n            self.subtasks = []\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskManager:\n    """Manages hierarchical task execution"""\n    def __init__(self):\n        self.tasks: Dict[str, Task] = {}\n        self.active_tasks: List[str] = []\n        self.completed_tasks: List[str] = []\n        \n    def add_task(self, task: Task):\n        """Add a task to the system"""\n        self.tasks[task.id] = task\n        \n    def execute_task(self, task_id: str) -> TaskStatus:\n        """Execute a single task"""\n        if task_id not in self.tasks:\n            return TaskStatus.FAILED\n            \n        task = self.tasks[task_id]\n        \n        # Check dependencies\n        for dep_id in task.dependencies:\n            if dep_id not in self.completed_tasks:\n                return TaskStatus.PENDING\n        \n        print(f"Executing task: {task.name}")\n        task.status = TaskStatus.RUNNING\n        \n        start_time = time.time()\n        \n        # Execute task based on type\n        \n        # For subtasks, execute them first\n        for subtask in task.subtasks:\n            subtask_status = self.execute_task(subtask.id)\n            if subtask_status != TaskStatus.SUCCESS:\n                task.status = TaskStatus.FAILED\n                task.actual_duration = time.time() - start_time\n                return task.status\n        \n        # Simulate task execution\n        if len(task.subtasks) == 0:\n            # Leaf task - actually do something\n            if "walk" in task.name.lower():\n                # Simulate walking\n                time.sleep(0.5)\n            elif "grasp" in task.name.lower():\n                # Simulate grasping\n                time.sleep(0.3)\n            elif "speak" in task.name.lower():\n                # Simulate speaking\n                time.sleep(0.2)\n        \n        task.status = TaskStatus.SUCCESS\n        task.actual_duration = time.time() - start_time\n        self.completed_tasks.append(task_id)\n        \n        print(f"Task completed: {task.name}")\n        return task.status\n    \n    def execute_task_tree(self, root_task_id: str):\n        """Execute entire task tree starting from root"""\n        print(f"Starting execution of task tree: {root_task_id}")\n        \n        # Build execution order considering dependencies\n        execution_order = self._get_execution_order(root_task_id)\n        \n        for task_id in execution_order:\n            status = self.execute_task(task_id)\n            if status == TaskStatus.FAILED:\n                print(f"Task tree failed at task: {task_id}")\n                return False\n        \n        print("Task tree completed successfully")\n        return True\n    \n    def _get_execution_order(self, root_task_id: str) -> List[str]:\n        """Determine execution order considering dependencies"""\n        order = []\n        visited = set()\n        \n        def dfs(task_id: str):\n            if task_id in visited:\n                return\n            visited.add(task_id)\n            \n            # Visit dependencies first\n            task = self.tasks[task_id]\n            for dep_id in task.dependencies:\n                if dep_id in self.tasks:\n                    dfs(dep_id)\n            \n            # Visit subtasks in order\n            for subtask in task.subtasks:\n                dfs(subtask.id)\n            \n            # Add current task\n            order.append(task_id)\n        \n        dfs(root_task_id)\n        return order\n\ndef create_sample_task_tree():\n    """Create a sample task tree for a complex humanoid task"""\n    tm = TaskManager()\n    \n    # Define low-level tasks\n    walk_forward = Task(\n        id="walk_1",\n        name="Walk Forward",\n        description="Move robot forward by 1 meter",\n        estimated_duration=2.0\n    )\n    \n    turn_left = Task(\n        id="turn_1", \n        name="Turn Left",\n        description="Turn robot 90 degrees left",\n        estimated_duration=1.0\n    )\n    \n    approach_object = Task(\n        id="approach_1",\n        name="Approach Object", \n        description="Move to object location",\n        estimated_duration=1.0\n    )\n    \n    grasp_object = Task(\n        id="grasp_1",\n        name="Grasp Object",\n        description="Grasp the target object",\n        estimated_duration=0.5\n    )\n    \n    raise_arm = Task(\n        id="raise_arm_1",\n        name="Raise Right Arm",\n        description="Raise right arm to head height",\n        estimated_duration=0.3\n    )\n    \n    speak_hello = Task(\n        id="speak_1",\n        name="Speak Hello",\n        description="Speak \'Hello\' to person",\n        estimated_duration=0.5\n    )\n    \n    # Define mid-level tasks\n    navigate_to_object = Task(\n        id="navigate_1",\n        name="Navigate to Object",\n        description="Navigate robot to object location",\n        subtasks=[walk_forward, turn_left, approach_object],\n        estimated_duration=4.0\n    )\n    \n    pickup_object = Task(\n        id="pickup_1", \n        name="Pick Up Object",\n        description="Pick up the target object",\n        subtasks=[navigate_to_object, grasp_object],\n        dependencies=["navigate_1"],\n        estimated_duration=4.5\n    )\n    \n    # Define high-level tasks\n    greet_and_assist = Task(\n        id="greet_assist_1",\n        name="Greet and Assist Person",\n        description="Greet person and assist with object",\n        subtasks=[raise_arm, speak_hello, pickup_object],\n        estimated_duration=6.0\n    )\n    \n    # Add all tasks to manager\n    for task in [walk_forward, turn_left, approach_object, grasp_object, \n                 raise_arm, speak_hello, navigate_to_object, pickup_object,\n                 greet_and_assist]:\n        tm.add_task(task)\n    \n    return tm, greet_and_assist.id\n\ndef demonstrate_task_hierarchy():\n    """Demonstrate the task hierarchy system"""\n    tm, root_task_id = create_sample_task_tree()\n    \n    print("Task Hierarchy Structure:")\n    print("========================")\n    \n    def print_task_tree(task_id: str, indent: int = 0):\n        task = tm.tasks[task_id]\n        print("  " * indent + f"\u2514\u2500 {task.name} (ID: {task.id})")\n        \n        for subtask in task.subtasks:\n            print_task_tree(subtask.id, indent + 1)\n    \n    print_task_tree(root_task_id)\n    \n    print("\\nExecuting task tree...")\n    success = tm.execute_task_tree(root_task_id)\n    \n    print(f"\\nExecution result: {\'Success\' if success else \'Failed\'}")\n    \n    # Print task statistics\n    print("\\nTask Statistics:")\n    print("================")\n    for task_id, task in tm.tasks.items():\n        status_symbol = {\n            TaskStatus.SUCCESS: "\u2713",\n            TaskStatus.FAILED: "\u2717", \n            TaskStatus.CANCELLED: "\u25cb",\n            TaskStatus.PENDING: "\u25cb",\n            TaskStatus.RUNNING: "\u2192"\n        }[task.status]\n        \n        print(f"{status_symbol} {task.name}: {task.actual_duration:.2f}s (est: {task.estimated_duration:.2f}s)")\n\nif __name__ == "__main__":\n    demonstrate_task_hierarchy()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"57-control-system-integration-patterns",children:"5.7 Control System Integration Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"571-service-oriented-architecture",children:"5.7.1 Service-Oriented Architecture"}),"\n",(0,a.jsx)(n.p,{children:"In ROS2, services provide request-response communication between components:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nROS2 service integration for humanoid control system\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile\nfrom std_srvs.srv import Trigger, SetBool\nfrom humanoid_robot_interfaces.srv import ExecuteBehavior, SetJointState\n\nclass ControlServiceManager(Node):\n    def __init__(self):\n        super().__init__(\'control_service_manager\')\n        \n        # Create services\n        self.behavior_service = self.create_service(\n            ExecuteBehavior,\n            \'execute_behavior\',\n            self.execute_behavior_callback\n        )\n        \n        self.joint_control_service = self.create_service(\n            SetJointState, \n            \'set_joint_state\',\n            self.set_joint_state_callback\n        )\n        \n        self.emergency_stop_service = self.create_service(\n            Trigger,\n            \'emergency_stop\',\n            self.emergency_stop_callback\n        )\n        \n        # Create clients for other services\n        self.balance_client = self.create_client(SetBool, \'balance_service\')\n        self.walk_client = self.create_client(ExecuteBehavior, \'walk_behavior\')\n        \n        self.get_logger().info(\'Control Service Manager initialized\')\n\n    def execute_behavior_callback(self, request, response):\n        """Handle behavior execution requests"""\n        behavior_name = request.behavior_name\n        self.get_logger().info(f\'Executing behavior: {behavior_name}\')\n        \n        # Execute the requested behavior\n        success = self.execute_requested_behavior(behavior_name, request.parameters)\n        \n        response.success = success\n        response.message = f"Behavior {behavior_name} {\'executed\' if success else \'failed\'}"\n        \n        return response\n\n    def set_joint_state_callback(self, request, response):\n        """Handle joint state setting requests"""\n        joint_positions = request.positions\n        joint_names = request.names\n        \n        self.get_logger().info(f\'Setting {len(joint_names)} joint positions\')\n        \n        # Set joint positions\n        success = self.set_joint_positions(joint_names, joint_positions)\n        \n        response.success = success\n        response.message = f"Joint states {\'set\' if success else \'failed to set\'}"\n        \n        return response\n\n    def emergency_stop_callback(self, request, response):\n        """Handle emergency stop requests"""\n        self.get_logger().info(\'EMERGENCY STOP REQUESTED\')\n        \n        # Stop all motion immediately\n        self.emergency_stop_all()\n        \n        response.success = True\n        response.message = \'Emergency stop executed\'\n        \n        return response\n\n    def execute_requested_behavior(self, behavior_name, parameters):\n        """Execute the requested behavior"""\n        # This would contain the actual behavior execution logic\n        # For demonstration, we\'ll just simulate different behaviors\n        \n        if behavior_name == \'walk\':\n            return self.execute_walk_behavior(parameters)\n        elif behavior_name == \'stand\':\n            return self.execute_stand_behavior(parameters)\n        elif behavior_name == \'sit\':\n            return self.execute_sit_behavior(parameters)\n        else:\n            self.get_logger().warn(f\'Unknown behavior: {behavior_name}\')\n            return False\n\n    def set_joint_positions(self, joint_names, positions):\n        """Set specified joint positions"""\n        # This would interface with the actual joint controllers\n        for name, pos in zip(joint_names, positions):\n            self.get_logger().debug(f\'Setting {name} to {pos} radians\')\n        return True\n\n    def emergency_stop_all(self):\n        """Emergency stop all robot motion"""\n        # This would send stop commands to all controllers\n        self.get_logger().info(\'Stopping all robot motion\')\n\n    def execute_walk_behavior(self, parameters):\n        """Execute walking behavior"""\n        # Implementation for walking\n        self.get_logger().info(\'Executing walking behavior\')\n        return True\n\n    def execute_stand_behavior(self, parameters):\n        """Execute standing behavior"""\n        # Implementation for standing\n        self.get_logger().info(\'Executing standing behavior\')\n        return True\n\n    def execute_sit_behavior(self, parameters):\n        """Execute sitting behavior"""\n        # Implementation for sitting\n        self.get_logger().info(\'Executing sitting behavior\')\n        return True\n\ndef main(args=None):\n    rclpy.init(args=args)\n    service_manager = ControlServiceManager()\n    \n    try:\n        rclpy.spin(service_manager)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        service_manager.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.h3,{id:"572-action-server-integration",children:"5.7.2 Action Server Integration"}),"\n",(0,a.jsx)(n.p,{children:"For long-running tasks, ROS2 actions are more appropriate:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nROS2 action server for complex humanoid behaviors\n"""\n\nimport rclpy\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom rclpy.node import Node\nfrom rclpy.executors import MultiThreadedExecutor\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nimport time\nfrom humanoid_robot_interfaces.action import NavigateToPose\n\nclass NavigateActionServer(Node):\n    def __init__(self):\n        super().__init__(\'navigate_action_server\')\n        \n        self._action_server = ActionServer(\n            self,\n            NavigateToPose,\n            \'navigate_to_pose\',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback,\n            callback_group=ReentrantCallbackGroup()\n        )\n        \n        self.current_goal = None\n        self._is_cancel_requested = False\n        \n        self.get_logger().info(\'Navigate Action Server initialized\')\n\n    def goal_callback(self, goal_request):\n        """Accept or reject goal requests"""\n        self.get_logger().info(f\'Received navigation goal: {goal_request.pose}\')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        """Accept or reject cancel requests"""\n        self.get_logger().info(\'Received cancel request\')\n        self._is_cancel_requested = True\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        """Execute the navigation goal"""\n        self.get_logger().info(\'Starting navigation execution\')\n        \n        feedback_msg = NavigateToPose.Feedback()\n        result = NavigateToPose.Result()\n        \n        target_pose = goal_handle.request.pose\n        current_pose = self.get_current_pose()  # Would get from TF or sensors\n        \n        # Calculate navigation plan\n        navigation_path = self.plan_path(current_pose, target_pose)\n        \n        if not navigation_path:\n            goal_handle.abort()\n            result.success = False\n            result.message = "No valid path found"\n            return result\n        \n        # Execute navigation\n        for i, waypoint in enumerate(navigation_path):\n            if self._is_cancel_requested:\n                goal_handle.canceled()\n                result.success = False\n                result.message = "Goal canceled"\n                self._is_cancel_requested = False\n                return result\n            \n            # Move to waypoint\n            success = self.move_to_waypoint(waypoint)\n            \n            if not success:\n                goal_handle.abort()\n                result.success = False\n                result.message = "Navigation failed at waypoint"\n                return result\n            \n            # Publish feedback\n            feedback_msg.current_pose = self.get_current_pose()\n            feedback_msg.distance_remaining = self.calculate_distance_remaining(\n                self.get_current_pose(), target_pose\n            )\n            goal_handle.publish_feedback(feedback_msg)\n            \n            self.get_logger().info(f\'Waypoint {i+1}/{len(navigation_path)} completed\')\n        \n        # Final check - reached target?\n        final_pose = self.get_current_pose()\n        distance_to_target = self.calculate_distance_to_target(final_pose, target_pose)\n        \n        if distance_to_target < 0.1:  # 10cm tolerance\n            goal_handle.succeed()\n            result.success = True\n            result.message = "Navigation completed successfully"\n        else:\n            goal_handle.abort()\n            result.success = False\n            result.message = f"Reached vicinity but not target (distance: {distance_to_target:.2f}m)"\n        \n        self.get_logger().info(f\'Navigation result: {result.message}\')\n        return result\n\n    def get_current_pose(self):\n        """Get current robot pose (would interface with localization system)"""\n        # Simulated pose\n        from geometry_msgs.msg import Pose\n        pose = Pose()\n        pose.position.x = 0.0\n        pose.position.y = 0.0\n        pose.position.z = 0.0\n        pose.orientation.w = 1.0\n        return pose\n\n    def plan_path(self, start_pose, end_pose):\n        """Plan a path from start to end pose"""\n        # Simple straight-line path for demonstration\n        path = []\n        for i in range(10):  # 10 waypoints\n            t = i / 9.0  # Parameter from 0 to 1\n            waypoint = Pose()\n            waypoint.position.x = start_pose.position.x + t * (end_pose.position.x - start_pose.position.x)\n            waypoint.position.y = start_pose.position.y + t * (end_pose.position.y - start_pose.position.y)\n            waypoint.orientation = end_pose.orientation\n            path.append(waypoint)\n        return path\n\n    def move_to_waypoint(self, waypoint):\n        """Move robot to specified waypoint"""\n        # Simulate movement\n        time.sleep(0.2)\n        return True\n\n    def calculate_distance_remaining(self, current_pose, target_pose):\n        """Calculate remaining distance to target"""\n        dx = target_pose.position.x - current_pose.position.x\n        dy = target_pose.position.y - current_pose.position.y\n        return (dx**2 + dy**2)**0.5\n\n    def calculate_distance_to_target(self, current_pose, target_pose):\n        """Calculate distance to target pose"""\n        return self.calculate_distance_remaining(current_pose, target_pose)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    \n    node = NavigateActionServer()\n    executor = MultiThreadedExecutor()\n    executor.add_node(node)\n    \n    try:\n        executor.spin()\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"58-integration-testing-and-validation",children:"5.8 Integration Testing and Validation"}),"\n",(0,a.jsx)(n.h3,{id:"581-system-integration-test-framework",children:"5.8.1 System Integration Test Framework"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nIntegration test framework for humanoid control system\n"""\n\nimport unittest\nimport threading\nimport time\nfrom unittest.mock import Mock, patch\nimport numpy as np\n\nclass MockSensorInterface:\n    """Mock sensor interface for testing"""\n    def __init__(self):\n        self.joint_positions = [0.0] * 28  # 28 DOF humanoid\n        self.imu_data = {\'roll\': 0.0, \'pitch\': 0.0, \'yaw\': 0.0}\n        self.force_data = [0.0, 0.0, 0.0, 0.0]  # 4 force sensors\n    \n    def get_sensor_data(self):\n        """Get mock sensor data"""\n        return {\n            \'joint_positions\': self.joint_positions,\n            \'imu_data\': self.imu_data,\n            \'force_data\': self.force_data\n        }\n\nclass MockActuatorInterface:\n    """Mock actuator interface for testing"""\n    def __init__(self):\n        self.command_history = []\n    \n    def send_commands(self, commands):\n        """Send commands to actuators"""\n        self.command_history.append(commands)\n        return True\n\nclass HumanoidControlSystem:\n    """Simplified humanoid control system for testing"""\n    def __init__(self, sensor_interface, actuator_interface):\n        self.sensor_interface = sensor_interface\n        self.actuator_interface = actuator_interface\n        self.running = False\n        self.balance_controller = MockBalanceController()\n        self.walk_controller = MockWalkController()\n    \n    def start(self):\n        """Start the control system"""\n        self.running = True\n        self.control_thread = threading.Thread(target=self.control_loop)\n        self.control_thread.start()\n    \n    def control_loop(self):\n        """Main control loop"""\n        while self.running:\n            # Get sensor data\n            sensor_data = self.sensor_interface.get_sensor_data()\n            \n            # Process with controllers\n            balance_commands = self.balance_controller.update(sensor_data)\n            walk_commands = self.walk_controller.update(sensor_data)\n            \n            # Combine commands\n            combined_commands = self.combine_commands(balance_commands, walk_commands)\n            \n            # Send to actuators\n            self.actuator_interface.send_commands(combined_commands)\n            \n            time.sleep(0.01)  # 100Hz control loop\n    \n    def combine_commands(self, balance_cmds, walk_cmds):\n        """Combine different controller commands"""\n        # Simple blending for demonstration\n        return balance_cmds + walk_cmds\n    \n    def stop(self):\n        """Stop the control system"""\n        self.running = False\n        if hasattr(self, \'control_thread\'):\n            self.control_thread.join()\n\nclass MockBalanceController:\n    """Mock balance controller"""\n    def update(self, sensor_data):\n        """Update balance control"""\n        # Simple balance response\n        imu = sensor_data[\'imu_data\']\n        return {\'torso_pitch\': -imu[\'pitch\'] * 5.0, \'torso_roll\': -imu[\'roll\'] * 5.0}\n\nclass MockWalkController:\n    """Mock walk controller"""\n    def __init__(self):\n        self.step_counter = 0\n    \n    def update(self, sensor_data):\n        """Update walk control"""\n        self.step_counter += 1\n        # Simple stepping pattern\n        if self.step_counter % 100 == 0:  # Every second\n            return {\'left_leg\': 0.1, \'right_leg\': -0.1}\n        return {}\n\nclass TestHumanoidControlSystem(unittest.TestCase):\n    """Test suite for humanoid control system"""\n    \n    def setUp(self):\n        """Set up test fixtures"""\n        self.sensor_mock = MockSensorInterface()\n        self.actuator_mock = MockActuatorInterface()\n        self.control_system = HumanoidControlSystem(\n            self.sensor_mock, \n            self.actuator_mock\n        )\n    \n    def test_initialization(self):\n        """Test system initialization"""\n        self.assertFalse(self.control_system.running)\n        self.assertEqual(len(self.actuator_mock.command_history), 0)\n    \n    def test_start_stop_cycle(self):\n        """Test starting and stopping the control system"""\n        self.control_system.start()\n        time.sleep(0.05)  # Run for a bit\n        self.assertTrue(self.control_system.running)\n        \n        self.control_system.stop()\n        self.assertFalse(self.control_system.running)\n    \n    def test_sensor_data_flow(self):\n        """Test sensor data acquisition and processing"""\n        self.control_system.start()\n        time.sleep(0.1)  # Run for enough cycles to get data\n        self.control_system.stop()\n        \n        # Check that actuator commands were generated\n        self.assertGreater(len(self.actuator_mock.command_history), 0)\n    \n    def test_balance_response(self):\n        """Test balance controller response to IMU data"""\n        # Simulate tilt\n        self.sensor_mock.imu_data[\'pitch\'] = 0.1\n        self.sensor_mock.imu_data[\'roll\'] = 0.05\n        \n        self.control_system.start()\n        time.sleep(0.05)\n        self.control_system.stop()\n        \n        # Check that balance commands were generated\n        has_balance_cmd = False\n        for cmd in self.actuator_mock.command_history:\n            if isinstance(cmd, dict) and \'torso_pitch\' in cmd:\n                has_balance_cmd = True\n                break\n        \n        self.assertTrue(has_balance_cmd, "Balance commands should be generated")\n    \n    def test_safety_monitoring(self):\n        """Test safety monitoring functionality"""\n        # Simulate dangerous tilt\n        self.sensor_mock.imu_data[\'pitch\'] = 0.5  # Very tilted\n        \n        # Test that system detects and responds appropriately\n        with patch(\'builtins.print\') as mock_print:\n            self.control_system.start()\n            time.sleep(0.05)\n            self.control_system.stop()\n            \n            # In a real system, this would trigger emergency stop\n            # Here we just verify the system can handle extreme values\n            self.assertTrue(True)  # Placeholder for actual safety test\n    \n    def test_integration_with_real_time_constraints(self):\n        """Test system behavior under real-time constraints"""\n        start_time = time.time()\n        \n        self.control_system.start()\n        time.sleep(1.0)  # Run for 1 second\n        self.control_system.stop()\n        \n        actual_duration = time.time() - start_time\n        expected_duration = 1.0\n        \n        # Allow for some timing variance\n        self.assertAlmostEqual(actual_duration, expected_duration, delta=0.1)\n        \n        # Check that we got approximately the right number of control cycles\n        expected_cycles = 100  # 100Hz for 1 second\n        actual_cycles = len(self.actuator_mock.command_history)\n        self.assertGreater(actual_cycles, expected_cycles * 0.9)  # Allow 10% variance\n\ndef run_integration_tests():\n    """Run all integration tests"""\n    print("Running Humanoid Control System Integration Tests...")\n    print("=" * 50)\n    \n    # Create test suite\n    loader = unittest.TestLoader()\n    suite = loader.loadTestsFromTestCase(TestHumanoidControlSystem)\n    \n    # Run tests\n    runner = unittest.TextTestRunner(verbosity=2)\n    result = runner.run(suite)\n    \n    print("\\n" + "=" * 50)\n    print(f"Tests run: {result.testsRun}")\n    print(f"Failures: {len(result.failures)}")\n    print(f"Errors: {len(result.errors)}")\n    print(f"Success rate: {(result.testsRun - len(result.failures) - len(result.errors)) / result.testsRun * 100:.1f}%")\n    \n    return result.wasSuccessful()\n\nif __name__ == "__main__":\n    success = run_integration_tests()\n    exit(0 if success else 1)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"59-real-world-integration-considerations",children:"5.9 Real-World Integration Considerations"}),"\n",(0,a.jsx)(n.h3,{id:"591-hardware-software-integration-challenges",children:"5.9.1 Hardware-Software Integration Challenges"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[Hardware Sensors] --\x3e B[Sensor Drivers]\n    B --\x3e C[ROS Message Conversion]\n    C --\x3e D[State Estimation]\n    D --\x3e E[Control Algorithms]\n    E --\x3e F[Low-Level Commands]\n    F --\x3e G[Hardware Actuators]\n    \n    H[Safety Monitor] --\x3e D\n    H --\x3e E\n    H --\x3e F\n    \n    I[Network Delays] -.-> C\n    J[Timing Jitters] -.-> E\n    K[Sensor Noise] -.-> D\n    L[Actuator Dynamics] -.-> F\n    \n    M[Performance Optimization] --\x3e E\n    N[Real-Time Scheduling] --\x3e G\n"})}),"\n",(0,a.jsx)(n.h3,{id:"592-system-reliability-and-fault-tolerance",children:"5.9.2 System Reliability and Fault Tolerance"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nFault tolerance system for humanoid robotics control\n"""\n\nimport time\nimport threading\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional, Callable\nimport logging\n\nclass ComponentStatus(Enum):\n    OPERATIONAL = "operational"\n    DEGRADED = "degraded" \n    FAILED = "failed"\n    RECOVERING = "recovering"\n    INITIALIZING = "initializing"\n\n@dataclass\nclass ComponentMonitor:\n    """Monitor for a single component"""\n    name: str\n    status: ComponentStatus\n    last_heartbeat: float\n    health_score: float\n    failure_count: int\n    recovery_count: int\n    emergency_procedures: List[str]\n\nclass FaultToleranceSystem:\n    """System for monitoring and handling component failures"""\n    def __init__(self):\n        self.components: Dict[str, ComponentMonitor] = {}\n        self.emergency_protocols: Dict[str, Callable] = {}\n        self.recovery_procedures: Dict[str, Callable] = {}\n        self.failure_history: List[Dict] = []\n        \n        # Logging\n        logging.basicConfig(level=logging.INFO)\n        self.logger = logging.getLogger(\'FaultTolerance\')\n        \n        # Start monitoring thread\n        self.monitoring_active = True\n        self.monitor_thread = threading.Thread(target=self.monitor_loop)\n        self.monitor_thread.start()\n    \n    def register_component(self, name: str, emergency_procedures: List[str] = None):\n        """Register a new component for monitoring"""\n        self.components[name] = ComponentMonitor(\n            name=name,\n            status=ComponentStatus.INITIALIZING,\n            last_heartbeat=0,\n            health_score=100.0,\n            failure_count=0,\n            recovery_count=0,\n            emergency_procedures=emergency_procedures or []\n        )\n        self.logger.info(f"Registered component: {name}")\n    \n    def register_emergency_protocol(self, event_type: str, handler: Callable):\n        """Register an emergency protocol handler"""\n        self.emergency_protocols[event_type] = handler\n        self.logger.info(f"Registered emergency protocol for: {event_type}")\n    \n    def register_recovery_procedure(self, component_name: str, procedure: Callable):\n        """Register a recovery procedure for a component"""\n        self.recovery_procedures[component_name] = procedure\n        self.logger.info(f"Registered recovery procedure for: {component_name}")\n    \n    def heartbeat(self, component_name: str, health_score: float = 100.0):\n        """Receive heartbeat from a component"""\n        if component_name in self.components:\n            component = self.components[component_name]\n            component.last_heartbeat = time.time()\n            component.health_score = health_score\n            \n            # Update status based on health score\n            if health_score < 30:\n                self.set_component_status(component_name, ComponentStatus.FAILED)\n            elif health_score < 70:\n                self.set_component_status(component_name, ComponentStatus.DEGRADED)\n            else:\n                self.set_component_status(component_name, ComponentStatus.OPERATIONAL)\n    \n    def set_component_status(self, component_name: str, status: ComponentStatus):\n        """Set component status with appropriate actions"""\n        if component_name in self.components:\n            old_status = self.components[component_name].status\n            self.components[component_name].status = status\n            \n            if status == ComponentStatus.FAILED and old_status != ComponentStatus.FAILED:\n                # Component just failed\n                self.handle_component_failure(component_name)\n            elif status == ComponentStatus.RECOVERING and old_status != ComponentStatus.RECOVERING:\n                self.handle_component_recovery(component_name)\n    \n    def handle_component_failure(self, component_name: str):\n        """Handle component failure"""\n        self.logger.error(f"Component failed: {component_name}")\n        \n        # Record failure\n        self.failure_history.append({\n            \'component\': component_name,\n            \'timestamp\': time.time(),\n            \'type\': \'failure\'\n        })\n        \n        # Increment failure count\n        self.components[component_name].failure_count += 1\n        \n        # Execute emergency procedures\n        component = self.components[component_name]\n        for proc_name in component.emergency_procedures:\n            if proc_name in self.emergency_protocols:\n                self.emergency_protocols[proc_name]()\n    \n    def handle_component_recovery(self, component_name: str):\n        """Handle component recovery"""\n        self.logger.info(f"Component recovering: {component_name}")\n        \n        # Execute recovery procedure\n        if component_name in self.recovery_procedures:\n            self.recovery_procedures[component_name]()\n        \n        # Increment recovery count\n        self.components[component_name].recovery_count += 1\n    \n    def monitor_loop(self):\n        """Main monitoring loop"""\n        while self.monitoring_active:\n            current_time = time.time()\n            \n            for name, comp in self.components.items():\n                # Check for timeout (no heartbeat in 2 seconds)\n                if current_time - comp.last_heartbeat > 2.0:\n                    if comp.status != ComponentStatus.FAILED:\n                        self.logger.warning(f"Heartbeat timeout for: {name}")\n                        self.set_component_status(name, ComponentStatus.FAILED)\n            \n            time.sleep(0.1)  # Check every 100ms\n    \n    def emergency_stop(self):\n        """Emergency stop all operations"""\n        self.logger.critical("EMERGENCY STOP ACTIVATED")\n        \n        # Set all components to failed state\n        for name in self.components:\n            self.set_component_status(name, ComponentStatus.FAILED)\n        \n        # Execute system-wide emergency protocols\n        if \'system_stop\' in self.emergency_protocols:\n            self.emergency_protocols[\'system_stop\']()\n    \n    def get_system_health(self) -> Dict[str, float]:\n        """Get overall system health summary"""\n        health_summary = {}\n        total_health = 0\n        operational_count = 0\n        \n        for name, comp in self.components.items():\n            health_summary[name] = comp.health_score\n            if comp.status == ComponentStatus.OPERATIONAL:\n                operational_count += 1\n            total_health += comp.health_score\n        \n        health_summary[\'overall_operational\'] = operational_count / len(self.components) if self.components else 0\n        health_summary[\'average_health\'] = total_health / len(self.components) if self.components else 0\n        \n        return health_summary\n    \n    def shutdown(self):\n        """Shut down the fault tolerance system"""\n        self.monitoring_active = False\n        if hasattr(self, \'monitor_thread\'):\n            self.monitor_thread.join()\n\ndef demo_fault_tolerance():\n    """Demonstrate fault tolerance system"""\n    print("Initializing Fault Tolerance System...")\n    \n    ft_system = FaultToleranceSystem()\n    \n    # Register components\n    ft_system.register_component(\'sensor_manager\', [\'safety_stop\'])\n    ft_system.register_component(\'motion_controller\', [\'safety_stop\'])\n    ft_system.register_component(\'balance_controller\', [\'safety_stop\', \'fall_prevention\'])\n    ft_system.register_component(\'communication_interface\', [])\n    \n    # Register emergency protocols\n    def safety_stop():\n        print("SAFETY STOP: Stopping all motion")\n    \n    def fall_prevention():\n        print("FALL PREVENTION: Initiating balance recovery")\n    \n    def system_stop():\n        print("SYSTEM STOP: All systems halted")\n    \n    ft_system.register_emergency_protocol(\'safety_stop\', safety_stop)\n    ft_system.register_emergency_protocol(\'fall_prevention\', fall_prevention)\n    ft_system.register_emergency_protocol(\'system_stop\', system_stop)\n    \n    # Register recovery procedures\n    def recover_balance():\n        print("RECOVERY: Balance system restored")\n    \n    ft_system.register_recovery_procedure(\'balance_controller\', recover_balance)\n    \n    # Simulate normal operation with some failures\n    print("\\nSimulating normal operation...")\n    \n    for i in range(20):\n        # Simulate heartbeats\n        ft_system.heartbeat(\'sensor_manager\', 95.0 - (i * 0.5) if i < 15 else 15.0)  # Sensor fails at step 15\n        ft_system.heartbeat(\'motion_controller\', 90.0)\n        ft_system.heartbeat(\'balance_controller\', 85.0 if i != 8 else 20.0)  # Balance fails at step 8\n        ft_system.heartbeat(\'communication_interface\', 98.0)\n        \n        time.sleep(0.3)\n        \n        if i == 5:\n            print(f"\\nStep {i}: System health = {ft_system.get_system_health()[\'average_health\']:.1f}%")\n        elif i == 8:\n            print(f"\\nStep {i}: Balance failure detected!")\n        elif i == 15:\n            print(f"\\nStep {i}: Sensor failure detected!")\n    \n    # Show final health\n    health = ft_system.get_system_health()\n    print(f"\\nFinal system health:")\n    for component, score in health.items():\n        if isinstance(score, float):\n            print(f"  {component}: {score:.1f}")\n    \n    # Check failure history\n    print(f"\\nFailure history: {len(ft_system.failure_history)} events")\n    for event in ft_system.failure_history:\n        print(f"  - {event[\'component\']} at step {int(event[\'timestamp\']) % 100}")\n    \n    # Cleanup\n    ft_system.shutdown()\n\nif __name__ == "__main__":\n    demo_fault_tolerance()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"511-summary",children:"5.11 Summary"}),"\n",(0,a.jsx)(n.p,{children:"Control architectures and system integration are fundamental to successful humanoid robotics. This chapter has covered:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Hierarchical control architectures"})," with their multi-tier organization"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Flowcharts and diagrams"})," illustrating system interactions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Software architecture patterns"})," including publish-subscribe and components"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Task decomposition systems"})," for managing complex behaviors"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Integration patterns"})," using ROS2 services and actions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Testing frameworks"})," for validating integration"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Fault tolerance systems"})," for reliable operation"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The hierarchical approach allows complex humanoid behaviors to be broken down into manageable components while maintaining real-time performance and safety."}),"\n",(0,a.jsx)(n.h2,{id:"512-discussion-questions",children:"5.12 Discussion Questions"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"How does the three-tier control architecture balance performance and functionality?"}),"\n",(0,a.jsx)(n.li,{children:"What are the advantages and disadvantages of publish-subscribe vs. service-oriented architectures?"}),"\n",(0,a.jsx)(n.li,{children:"How can fault tolerance be designed into real-time control systems?"}),"\n",(0,a.jsx)(n.li,{children:"What challenges arise when integrating multiple subsystems with different timing requirements?"}),"\n",(0,a.jsx)(n.li,{children:"How might control architectures evolve as humanoid robots become more autonomous?"}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var s=t(6540);const a={},o=s.createContext(a);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);